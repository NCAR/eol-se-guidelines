{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EOL Software Development Guidelines","text":"<p>This document is also available as a PDF.</p> <p>Math test:</p> \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] \\[      e_p = \\frac{5417.98 e_s}{t_n^2} \\\\      t_n = t_n + \\frac{e_o-e_s}{e_p} \\\\      t_s = |t_m-t_n| \\\\      t_m = t_n \\\\      e_s = 10^{9.4051-\\frac{2353}{t_n}}  \\]"},{"location":"Agile-Software-Development/","title":"Agile Software Development","text":"<p>Agile software development is a family of development processes based on a set of principles which align well with existing practice and culture in EOL.</p> <p>Our software development projects, particularly those that emphasize iteration and evolving scientific requirements and instrumentation, may benefit from adopting aspects of the agile software development methods. As examples, releasing working software early and throughout the development process allows users and domain experts to give continuous, valuable, and relevant feedback. This encourages the exchange of new ideas, a cooperative and interactive software development environment, and should result in the creation of valuable and useful software. Test-driven development emphasizes writing tests first, which helps to clarify purpose and verify that software works as expected.</p> <p>Agile software development is a people-oriented, collaborative development approach with the flexibility to respond quickly to changes. The Agile methodology family includes techniques such as Extreme Programming (XP), SCRUM (project management framework), LEAN, Feature-Driven development (FDD), Test- Driven development (TDD), and Dynamic Systems Development Method (DSDM). There are many options and no specific engineering practices are prescribed.</p> <p>Agile Software Development process ideas are based on the Agile Manifesto and its associated basic principles (www.agilemanifesto.org).</p> <p>Next page: Development Process</p>"},{"location":"Code-Sprints/","title":"Code Sprints","text":"<p>Code sprints have been used by many open-source projects and have evolved along with the agile development methods.</p> <p>Here are a few noteworthy points learned from the Aeros Qt4 porting sprint:</p> <ul> <li>There is a significant effort to setting up infrastructure before the   sprint, such as making sure everyone has a current, working, building source   code checkout, with all of the requisite library dependencies installed.</li> <li>It takes longer than you think it will.</li> <li>There is a benefit to being removed from distractions and working   collaboratively in a concentrated group.</li> <li>It may help to make more people aware of the sprint, since more people have   a stake in the outcome than participate in the sprint.</li> <li>It is invaluable to have test suites in place before the sprint which   already pass. The tests help verify that the changes have not broken   anything that was working before the sprint. The more automated,   comprehensive, and convenient the tests are, the more effective they are.</li> </ul> <p>Next page: Coding Guidelines</p>"},{"location":"Coding-Guidelines/","title":"Coding Guidelines","text":"<ul> <li>Coding Guidelines<ul> <li>Use automated builds.</li> <li>Use automated testing.</li> <li>Use continuous integration testing.</li> <li>Use compilers effectively.</li> <li>Use revision control.</li> <li>Use a logging framework</li> <li>Use a consistent style</li> <li>Facilitate code reuse.</li> <li>Deploy tests and logging as part of production software.</li> <li>Document.</li> <li>Do not optimize prematurely.</li> </ul> </li> </ul> <p>The coding guidelines relate to source code, implementation, and to the artifacts and infrastructure which should be part of development. Of course there is much overlap between process and coding.</p>"},{"location":"Coding-Guidelines/#use-automated-builds","title":"Use automated builds.","text":"<p>Every project should be easy to build from checkout with an automated, batch build process. For C++ applications, SCons is recommended for its existing support of EOL tools, libraries, and common third-party components. Java projects might use ant or Eclipse. Whatever the tool, building and testing should be turnkey. [See the Joel Test, step 2.]</p>"},{"location":"Coding-Guidelines/#use-automated-testing","title":"Use automated testing.","text":"<p>Use a testing framework like boost.test, cppunit, JUnit, cxxunit, or whatever, but integrate the testing into the automated build framework so it is easy to run the tests and detemine either pass or failure, without manually inspecting or comparing the output. A script which runs the program and tests for basic output is still helpful, sometimes called a smoke test. The more automated the testing, the more the computer can help by running the tests continuously on every change, often while further development continues simultaneously. One of the ideas behind the test-driven development process is that writing tests also helps the developer think clearly about the scope and the requirements, before writing the code.</p>"},{"location":"Coding-Guidelines/#use-continuous-integration-testing","title":"Use continuous integration testing.","text":"<p>Take advantage of buildbot or other tools to run builds and tests whenever code is committed, potentially on multiple platforms, without doing it manually.</p>"},{"location":"Coding-Guidelines/#use-compilers-effectively","title":"Use compilers effectively.","text":"<p>Most compilers can warn about questionable code constructs, such as missing return statements, unreached code, missing cases, unsafe type conversions. These warnings should always be enabled, and the code should compile cleanly without any warnings. This also works well with automated testing and continuous integration, since the compile step will report warnings whenever suspicious code has been added. When there is a warning, change the code. That way another developer later does not need to wonder whether the warning or the code is correct. GCC has the recommended -Wall and -Wextra options, but it also has the -Weffc+ option, which warns about violations of the style rules in Effective C++ [Meyers].</p> <p>Very often code quality improves when it must be compiled on different platforms and with different compilers. On Linux, there are compilers available besides GCC, such as Clang from the LLVM project and the Intel compiler, and these may find and report different problems in the source code.</p>"},{"location":"Coding-Guidelines/#use-revision-control","title":"Use revision control.","text":"<p>There are subversion and git servers already available to use. If any of the guidelines in this document should be an absolute requirement, this is one of them. Beyond just using revision control, there are also good guidelines for commits and commit messages, such as this article On commit messages. [See the Joel Test, step 1.] Here are a couple highlights:</p> <ul> <li>Do not mix cosmetic changes with functional changes. It is hard to see from   a source code diff what behavior changed if many more source lines differ   just because of reformatting or reindenting or renaming.</li> <li>Commit unrelated fixes separately when feasible. That allows individual   fixes to be understood separately and also backed out separately.</li> <li>Do not \u201cbreak the build\u201d. The trunk revision should always build without   errors so no one has to fix compile problems just to keep working on their   own changes. Commit intermediate, build-breaking changes onto a branch.</li> <li>Write a descriptive log message. On many projects the log message will be   emailed automatically to other interested persons, so the log message is an   easy way to send out a simple notice and explanation of a change.</li> </ul>"},{"location":"Coding-Guidelines/#use-a-logging-framework","title":"Use a logging framework","text":"<p>For the original developer, this may not seem useful at first, but it\u2019s value comes for other developers who later have to learn how the software works. Log messages can be valuable clues into which parts of the code are doing what when, and where a problem may be happening.</p> <p>Also, when software runs remotely, perhaps even autonomously, logs are invaluable because they can be retrieved by logging into the system or by email from the field operator. A good log can give important diagnostics more completely and more accurately than can be relayed over a phone call.</p> <p>See Logging Frameworks.</p>"},{"location":"Coding-Guidelines/#use-a-consistent-style","title":"Use a consistent style","text":"<p>There are many coding styles out there, and we will never settle upon just one, but there are some good conventions to follow. The important thing is to pick a style and be consistent. See [RAL], the Google style guide, and [KDE] for other ideas about style. For the record, here is a basic list of good practices in EOL:</p> <ul> <li> <p>Differentiate class members from local variables with a naming convention.</p> </li> <li> <p>Use a naming convention for class methods and functions, such as camel case   (doThat) or underscores (do_that), and then use the convention consistently.</p> </li> <li> <p>Use descriptive names. Do not abbreviate too much or leave out arbitrary   letters just to have a shorter name.</p> </li> <li> <p>Avoid long function definitions.</p> </li> <li> <p>Separate interface and implementation. In C++, the header file often can use   forward declarations rather than including other header files, which   simplifies dependencies and speeds compilation. When implementations are   defined in source modules rather than header files, then implementations can   change without forcing clients of the interface to recompile. Consider using   the pimpl idiom. For languages like Python and Java which force   implementation to be defined with interface, use the language to make public   interface explicit. The Python convention is to use leading underscores for   private methods.</p> </li> <li> <p>Favor spaces over tabs. Indenting by 8 spaces is excessive, 2 or 4 is   adequate.</p> </li> <li> <p>Avoid overcrowding source code. Use spaces around operators.</p> </li> <li> <p>Keep source code lines within 80 columns.</p> </li> <li> <p>Avoid complicating the flow of an algorithm just to optimize it, unless the   performance has been measured. The compiler optimizes better than   programmers. Premature optimization is the root of all evil, and often it is   also the root of all obfuscation.</p> </li> </ul>"},{"location":"Coding-Guidelines/#facilitate-code-reuse","title":"Facilitate code reuse.","text":"<p>There are many existing software implementations that we can use in EOL software projects. We should take advantage of them to avoid duplicating effort. We should also write our own code to facilitate its reuse in other EOL projects. Sometimes tools can help in searching for and identifying existing code. (At one point EOL had an OpenGrok server which could be used to search almost all of the EOL software repositories for specific code symbols or arbitrary text.  A capability like that would still be useful.) And of course there is no substitute for just asking around, either in person or on the software engineering mailing lists.</p> <p>There are many scripts and programs which at first look like one-off tasks, such as data processing specific to a single field project. We know from experience that usually a very similar task comes along, so software gets copied and slightly modified. Code reuse implies avoiding these copies. Instead, make the scripts modular and configurable so code does not need to be copied in whole, but instead code can be shared and maintained for multiple projects and similar tasks. Consolidate similar code into functions, consolidate functions into libraries and packages, share a single code base instead of duplicating it.</p> <p>This is similar to the coding maxim Don\u2019t Repeat Yourself (DRY). Avoid copy-n-paste of more than a few lines of code.</p>"},{"location":"Coding-Guidelines/#deploy-tests-and-logging-as-part-of-production-software","title":"Deploy tests and logging as part of production software.","text":"<p>It should be possible to test software in its production environment, using the same automated tests used in the development environment. Likewise, the built-in logging capabilities should be available in production and not disabled or compiled out.</p>"},{"location":"Coding-Guidelines/#document","title":"Document.","text":"<p>Short of mandating formal documentation requirements, it would be prudent to at least have some documentation goals. There are two types of documentation to address: programmer guides (API) and user guides. For API, at the minimum, there are almost effort-less tools now for generating API documentation from source code comments. These include doxygen, pydoc, sphinx, and javadoc. Public APIs should be commented, and they may as well be commented in a form from which online documentation can be generated. For user guides, there is no obvious answer. Some projects have used wikis effectively, especially when the wiki content can be downloaded for offline access in the field. The important point is that users should have documentation for basic operations. For operating instruments or processing data in the field, it is crucial that users have convenient and documented methods to verify that the software and instrument are operating normally. This means the software must support diagnosis (see logging) and troubleshooting, and the user guide must document the use and meaning of the diagnostics.</p>"},{"location":"Coding-Guidelines/#do-not-optimize-prematurely","title":"Do not optimize prematurely.","text":"<p>See all the references on the web about Knuth\u2019s quote, the 80/20 rule, and other challenges to performance metrics. Basically, there is little point to optimizing code unless it\u2019s performance will be measured accurately both before and after the optimization. Never do for the compiler what the compiler can do for you. In other words, the compiler may already be optimizing code that you think appears slow, so optimizing manually is like fighting the compiler. Don\u2019t bother unless you can verify where the compiler actually needs help.</p> <p>Next page: Tools and Technologies</p>"},{"location":"Development-Process/","title":"Development Process","text":"<p>This section outlines phases and infrastructure related to the software development lifecycle, but not a sequential timeline.</p>"},{"location":"Development-Process/#requirements","title":"Requirements","text":"<p>Rather than suggest a specific requirements discovery process, here are some issues that should always be considered when identifying the requirements for an EOL software project. These are not necessarily important for all EOL software, but they should not be overlooked. For example, for data-critical applications, the requirements must address data integrity and redundancy. High-bandwidth applications must identify the total throughput needed, so the throughput can be tested and verified.</p> <p>As part of the requirements process, it is especially important to identify the users, since users must be involved in defining the requirements. In other words, a requirement can be posed as a question, and the users and domain experts should answer it, not the developer. (Unless the developer is a user also, of course.) The intended users also impact the target platforms, implementation language, and dependencies.</p> <p>As a practical implication, users should be invited to any meeting where requirements will be discussed. [HFSD] and [FOWLER] have straightforward explanations of the necessity and value of close user involvement for iterative requirements analysis and development.</p> <p>Some statement of requirements is necessary for any size of development, large or small. Larger developments will have more requirements, but they do not need to be specified all at once. Instead they may be discovered as part of an iterative process. The important thing is that they be defined and documented along the way, so the software can be developed with the correct requirements in mind, ideally to the point of developing tests to verify the requirements.</p> <p>Writing use cases and user stories is good practice for elucidating requirements. They can be written from the user\u2019s point of view, and they only present the behavior expected by users without being biased by design or implementation. It is natural to describe software by telling a story about what it does and how the functionality will be used. Stories also force consideration of error handling from the user\u2019s point of view: how should the application and user interact when an error case occurs?</p> <p>Here is a list of requirements to consider, in no particular order:</p> <ul> <li>software lifetime: How long will the software be needed? This   requirement distinguishes the one-off fixes from longer term software   infrastructure.</li> <li>external support: Does the software need to be deployed for users   outside of EOL?</li> <li>target platforms: Does the software need to run on multiple platforms,   embedded or not, particular operating systems, and so on? Is there a   requirement for data portability between architectures?</li> <li>data security: How robust and redundant does the data manipulation and   storage need to be? Raw data recording obviously needs stricter data   security requirements than reprocessing software, but someone still needs to   decide how many backups are enough.</li> <li>access security: Do user authentication and authorization need to be built   into the software?</li> <li>monitoring: How will users and operators monitor the status and progress   of the software?</li> <li>auditing: When processing data, what metadata will be preserved and   augmented and tracked?</li> <li>data formats: What data file formats must be supported for input and   output?</li> <li>error recovery: Does the software need to be able to recover quickly   from problems, such as during field operations? Perhaps it needs to save   checkpoints and be able to resume from the last checkpoint. What errors need   to be detected automatically and how will the operator be alerted?</li> <li>data throughput: What is the minimum data throughput requirement? Even   post-processing software may have a throughput requirement, if the users   want to process field project data in hours instead of days.</li> <li>algorithm flexibility: Some software may need special accommodation to   support alternative and evolving algorithms.</li> <li>configuration: How flexible does the software configuration need to be?   Will it operate for different field projects, test modes, and instrument   modes?  Will different users need to run it with their own customizations?   Where will it get configuration settings and metadata?</li> </ul>"},{"location":"Development-Process/#design","title":"Design","text":"<p>In any software project, there are many alternative designs which all meet the requirements. The challenge for developers is finding a design which meets the requirements but also can be implemented, communicated, maintained, and elaborated as effectively as possible. The software abstraction should map well to the domain, and the language and concepts in the design should facilitate communication about the problem rather than confuse it. Thus documentation of the design is important.</p> <p>One best practice seems to be a coherent and consistent partition of the problem into logical components, a basic block diagram, following as closely as possible the vocabulary of the problem domain. The partitioning then maps directly to the namespaces and symbol names used in the code. A design document or block diagram describes the components, their responsibilities, and their collaborations, and as such it serves as an overview of the design as well as a guide to the symbols in the source code.</p> <p>UML diagramming tools can be helpful here, but so far the experience with them in EOL is limited. As more EOL developers become familiar with UML notation, it will be more feasible to share and discuss designs through UML diagrams.</p>"},{"location":"Development-Process/#design-reviews","title":"Design reviews","text":"<p>Software design reviews have not really been tried in EOL, but they still seem like a good idea. As an action item from this report, we should make an effort to hold design reviews before anything is implemented, even if the review is informal.</p> <p>Typically, the participants in design reviews will be other developers, as well as perhaps a domain expert to help clarify the requirements. That said, EOL software designs often must compromise between requirements. For example, there may be trade-offs between bandwidth available on the current hardware versus new software that would be needed for new hardware. Also, the priority of each requirement must be decided by the users. (For iterative developments, this relates to selecting which feature to implement in the next iteration.) For these reasons, users often need to be involved in design reviews also.</p> <p>An iterative development will have multiple reviews, one for each iteration of the design.</p>"},{"location":"Development-Process/#documentation","title":"Documentation","text":"<p>Documentation is part of both process and infrastructure. There are certain aspects to a software development that should be documented before coding should continue:</p> <ul> <li>Requirements</li> <li>Design</li> <li>User experts</li> <li>Guidelines checklist</li> <li>Project home page</li> </ul> <p>For smaller projects (or small iterations), the requirements may be just a statement about objective, and the design documentation may not be very involved either. However, even a small project requires decisions about implementation language, data formats, GUI framework (or not), basic classes, and so on. As part of the design documentation, it is helpful to document critical design choices which were rejected rather than only the choices which were selected.</p> <p>The domain experts are the stakeholders in the software and those who will know the most about whether the software is accurately modeling the application domain. Usually the domain experts are obvious, but it helps to name them explicitly in the documentation, since they are important references for the software developers. As the wisdom goes, software analysis does not happen unless a domain expert is involved. [FOWLER]</p> <p>An example has been created for the checklist, linked below:</p> <ul> <li>Software Project Template</li> </ul> <p>The purpose of the checklist is to communicate to others, clarify who has a role in the development and what that role is, provide a quick overview for those not directly involved in the project, and provide a single point of reference for project status and all artifacts of the project. Filling in a checklist assures that important infrastructure is planned for and taken care of ahead of time, such as revision control, wiki pages (or wherever the project checklist will reside), issue tracking, and so on.</p> <p>Note that for an iterative development, where features are implemented in incremental changes to working software, all of the above documentation requirements still hold. Before a new feature can be implemented, requirements should state what the feature will do, there must be a design in mind for the feature, and user experts must have been consulted about the feature.</p>"},{"location":"Development-Process/#code-reviews","title":"Code reviews","text":"<p>This is another idea from industry, promoted as beneficial and worth the effort, which EOL has never really tried. Emails on code commits allow for sporadic code review of a sort, and we have the Crucible code review tool available in EOL, but we\u2019re not taking full advantage of this. The report Software Practice in the Ptolemy Project is very positive about code reviews, and the experience there should be very relevant to EOL.</p> <p>As a minimal guideline, since every project should be using revision control, every project should likewise be taking advantage of commit emails. Setting up emails on code changes is convenient, and it greatly boosts communication and awareness between developers as far as notifying everyone exactly what is happening in the source tree.</p>"},{"location":"Development-Process/#releases","title":"Releases","text":"<p>Software releases are very ad hoc at the moment across all the projects. We need to adopt a more consistent process for software release. To avoid confusion, the process should be the same for users both inside and outside EOL, even if some software is only available within EOL. More formal releases make for more consistent software quality and revision tracking \u201cin the wild\u201d. It also eases the maintenance burden on users, especially \u201cunintended side effects\u201d when production software is upgraded without warning and at arbitrary times. A release should be tagged, tested, packaged, advertised, available, and supported. Release announcements and release notes should be in a single location on the web. Release notes should include a summary of what has changed in the release.</p>"},{"location":"Development-Process/#acceptance-or-bug-fix-phase","title":"Acceptance or bug-fix phase","text":"<p>All software when first released goes through a phase where users first start using it, learning it, and discovering bugs in it. We may as well identify this phase and work to make it go smoothly. Many open-source projects (GCC, KDE, Linux Kernel) have a bug-fix-only phase, where work on new features stops in favor of fixing all of the high-priority bugs. This phase can be helped by running (and passing!) tests to verify requirements as well as regression tests to prevent bugs from recurring. Perhaps EOL developments don\u2019t warrant a formal or even an informal acceptance phase, but all projects should plan to spend time focusing exclusively on fixing bugs. [See the Joel Test, step 5.]</p>"},{"location":"Development-Process/#maintenance","title":"Maintenance","text":"<p>In many ways maintenance is its own step in the software development process. Porting to new environments or OS revisions likely does not require analysis or design, but it does require development time. It is difficult to predict the resources needed for maintenance, but some maintenance issues can be seen coming. For example, external dependencies may go away or change (Qt4), formats may change (netcdf 4), hardware may change (64-bit), and new technologies may need to be adopted (web, rpm).</p>"},{"location":"Development-Process/#pair-programming","title":"Pair programming","text":"<p>Pair programming is a technique from agile software development where two programmers work simultaneously developing code, side-by-side at the console, each with a specific role. It has been used in EOL before, but otherwise there has been little experience with it. Pair programming may be a good way to spread and encourage \u201cgood coding habits\u201d, besides the potential for producing better code.</p>"},{"location":"Development-Process/#share-programming","title":"Share programming","text":"<p>This is an idea to increase cooperation, collaboration, and mentoring opportunities among EOL programmers by purposely sharing development projects among multiple developers. Unlike pair programming, programmers can still code separately, but they cooperate on the same project and the same source tree. For example, instead of two developers each working alone on a single project, two developers could share development on two projects.</p> <p>As a general rule, programmers should not hesitate to seek discussion with other programmers to help solve a problem or share techniques. This practice can guard against the single point of failure problem. When only one programmer works on software, then support and fixes fall on that programmer, and that can be a bottleneck. If instead more than one programmer is familiar with the software, then support can be distributed. This may be an item to address explicitly in the project checklist. A project should decide ahead of time how critical cross-training and distributed support will be for the success of the software. If it is critical, then shared programming or other practices could be employed to spread out the support responsibilities.</p>"},{"location":"Development-Process/#code-sprints","title":"Code sprints","text":"<p>Sprints have proved useful in EOL as a way to focus a group of people for a short period on solving a particular problem.</p> <p>Next page: Code Sprints</p>"},{"location":"Logging-Frameworks/","title":"Logging Frameworks","text":"<p>This is a quick survey of logging frameworks either used in EOL or which seem like good candidates for use.</p>"},{"location":"Logging-Frameworks/#nidas","title":"NIDAS","text":"<p>https://www.eol.ucar.edu/software/nidas/doxygen/html/d0/d58/group__Logging.html</p> <p>The NIDAS utility library contains a home-built logging interface. It is self- contained, and it could be possible to adopt it underneath logx to replace other software\u2019s dependency on log4cpp. That would go a long way towards trimming down the number of logging frameworks in use in EOL, and maybe the NIDAS log library would see more development if it were more widely used.</p> <ul> <li>in-house</li> <li>simple active() check before generating message</li> <li>can be completely compiled out</li> <li>fixed set of metadata: time, level, file, function, line, tag,</li> <li>not hierarchical</li> <li>only single output logger available, either syslog or stream</li> <li>multithread only</li> <li>fixed format, but fields can be suppressed</li> </ul>"},{"location":"Logging-Frameworks/#boostlog","title":"Boost.Log","text":"<p>As of Boost 1.54, the Boost library has an official logging framework:</p> <p>http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/index.html</p> <ul> <li>any metadata</li> <li>filter on any metadata</li> <li>threading supported by templates</li> <li>support wide characters</li> <li>formatters associated with each sink</li> <li>built-in syslog, stream, and rotating file backends</li> <li>built-in timers</li> <li>short-circuits message generation without calling a test function</li> </ul>"},{"location":"Logging-Frameworks/#log4cpp","title":"LOG4CPP","text":"<p>http://log4cpp.sourceforge.net/</p> <ul> <li>widely-used, familiar, portable API (based on Java log4j)</li> <li>categories</li> <li>hierarchical</li> <li>some standard configuration options and output formats supported (eg, xml)</li> <li>particular implementation we\u2019ve used is not under active development</li> <li>Nested Diagnostic Contexts</li> </ul> <p>In EOL, the logx library is a thin wrapper to log4cpp. It adds convenience methods for things like command-line options and a module-scope logging category instance with the LOGGING() macro. logx also adds scoped logging: the ability to log a message when an object comes into scope and then when it leaves scope.</p>"},{"location":"Logging-Frameworks/#log4cxx-apache","title":"log4cxx (Apache)","text":"<p>http://logging.apache.org/log4cxx/</p> <p>I do not know of any uses in EOL, but anything from the Apache project seems worthy of consideration. It is based on the log4x API, and it should be very portable.</p> <ul> <li>requires APR</li> <li>under active development</li> <li>Nested Diagnostic Contexts</li> <li>built-in configuration</li> </ul>"},{"location":"Logging-Frameworks/#log4j","title":"Log4J","text":"<p>I believe the de facto standard for Java, with concepts like Loggers, Appenders, Layouts, and Categories.</p>"},{"location":"Logging-Frameworks/#for-further-thinking","title":"For Further Thinking","text":"<p>Logging should never be compiled out. If you need it during development, someone else will need it in development, and they should not have to recompile the tree with new cpp symbol definitions just to get new diagnostic logging. If it\u2019s useful during development, it will likely be useful for testing and diagnostics on operational code, but only if the logging was left compiled in. A good logging framework allows expensive message generation to be skipped if it will not be logged.</p> <p>Rather than sending messages with statistics, send the statistics and let the consumer format. Sometimes consumer needed to print to a file or terminal, sometimes it was a GUI needing to fill in a label. Plus it saves space to send just the numbers. This introduces the idea of deferring formatting as long as possible, instead allowing attributes to logged which can be retrieved and handled later in some custom manner. The boost::logging library provides this kind of functionality.</p> <p>It seems like logging and messaging and monitoring should converge to use the same mechanism. If there\u2019s some point in the software with valuable information to report, then the distinctions between a log message and an event publication and a status message become arbitrary.</p> <p>Other features for which we\u2019ve had a need: automatic or configurable throttling, dynamic run-time configuration, stack traces, inventory of log points (probably best generated by scanning the source).</p> <p>Next page: Updating the Guidelines</p>"},{"location":"Project-Management/","title":"Project Management","text":"<p>Some aspects of software development naturally relate to project management, especially when the software is only one part of a larger project.</p>"},{"location":"Project-Management/#consult-on-project-management","title":"Consult on Project Management","text":"<p>Software projects can be completed in an efficient and organized manner by using a project management framework. Project management professionals can provide guidance on the right process level for your project type and size. They are trained to help you select the methods most likely to benefit your project. Whenever it is important to reach a goal quickly, predictably, and with high quality results, project management tools and processes can be used to your advantage.</p> <p>Two organizations specializing in project management methods and certifications are the Project Management Institute (PMI) and the Scrum Alliance.</p>"},{"location":"Project-Management/#use-agile-development-practices","title":"Use Agile Development Practices","text":"<p>Agile software development processes facilitate a cooperative and interactive software development.</p> <ul> <li>Agile Software Development</li> </ul>"},{"location":"Project-Management/#hold-project-reviews","title":"Hold project reviews","text":"<p>For some projects, it may make sense to expand the design review concept into a more general project review. The purpose would be to review and collaborate on all aspects of the project , such as the requirements, design, implementation, milestones, priorities, risks, technology selections, and other initial decisions. This would be the opportunity for other experts (like project management experts) and other developers to learn about and help guide the project, so the project benefits from the combined development experience in EOL.</p> <p>Even without an actual project review meeting, developers should actively seek input from other developers and other experts. This seems to be accepted as a good practice in EOL, and it is consistent with the principle of cooperation, but the practice must actively be encouraged. It would be a natural extension to the project checklist (see the Software Project Template) to include which developers have consulted on the design and implementation of the software. Project reviews also give less experienced software engineers a chance to question and learn about good development practices.</p>"},{"location":"Project-Management/#track-issues","title":"Track issues","text":"<p>At present, issue tracking is not something that is used widely or regularly. Users would not be expected to use it, but certainly it should be kept open and available to everyone. An issue tracking tool also could be an important resource for tracking progress, but only if developers use it and keep it current.</p>"},{"location":"Project-Management/#track-progress","title":"Track progress","text":"<p>Some of the process guidelines relate to tracking the progress of a project, such as the project overview page and issue tracking. The questions are whether more tracking is needed and what are the best practices for tracking and reporting progress. Project tracking would benefit users, developers, and managers. Here are some notable pieces to the progress tracking picture:</p> <ul> <li>Participation in regular project meetings</li> <li>Milestones on a web or wiki page, with the current status of each milestone</li> <li>Issue tracking, possibly with time tracking also</li> <li>Emails on commits</li> <li>Project overview page, with a field for current status and latest progress</li> <li>Blogs, by developers and by project leads</li> </ul> <p>All of these have been used in some form or other in EOL. As a minimum, every software development should have a web site which hosts the project checklist, ideally with something like a blog for status updates. The web site could be a wiki page, an EOL plone page, or a project wiki on the UCAR wiki. A directory of all of these web sites would be a comprehensive list of all software developments in EOL.</p> <p>Even if a long range schedule and formal milestones are not possible, a software development can still report on the current efforts and impending tasks using the same mechanisms.</p> <p>Next page: Development Process</p>"},{"location":"Purpose-and-Principles/","title":"Introduction","text":""},{"location":"Purpose-and-Principles/#purpose","title":"Purpose","text":"<p>These guidelines describe best practices for software engineering in EOL. The purpose of these guidelines is to improve the development experience for users, yield better software for EOL, encourage a common set of good software engineering practices within EOL, and nurture software development skills which will best serve EOL and its scientific community. As we try to improve all of our software developments, these guidelines can be a resource to improve development in similar ways towards similar goals.</p> <p>These guidelines are not intended to be mandates. The guidelines encourage some practices more strongly than others, but none are absolute requirements. Most of the practices can be adopted individually and incrementally, for any scale of software development, and by anyone developing software, not just software engineers.</p> <p>In this document, key practices will be emphasized in bold, while further details and discussion may be referenced on a separate page. The bottom of this page provides quick references with links to specific sections and details.</p> <p>Many people have contributed to this document, in particular Gary Granger, John Allison, Linda Cully, and Sandra Thurn, with helpful input from many others in EOL. It is meant to be an evolving and organic document that all in EOL are welcome to edit. If you have questions about this document, email Gary.</p>"},{"location":"Purpose-and-Principles/#principles","title":"Principles","text":"<p>The EOL software engineering first principles are the motivation for improving our software development process and the measure of the effectiveness of our software engineering practices. From these principles follow the best practices we want to follow.</p> <p>EOL software engineering practices emphasize and facilitate utility, efficiency, flexibility, reliability, accountability, and cooperation.</p> <p>Software development in EOL must be flexible to adapt to evolving research, instruments, deployments, and data. Like the research instruments and research data themselves, software will often be prototypes or cutting edge, but quality and maintainability need not suffer. Development must adapt to advances in software engineering tools and techniques.</p> <p>Software developments must be efficient to make the most of limited software engineering resources to support EOL\u2019s mission. They must accommodate timelines dictated by available instrument hardware and field project deadlines.</p> <p>The goal of any EOL development is to provide a useful tool or product to the EOL user community. EOL software engineers must be accountable and available to that community. We must work closely with the community to understand needs, solve problems, and fulfill requirements.</p> <p>The culture among EOL software engineers is based on supporting science and solving technical problems in a spirit of cooperation across all disciplines.</p>"},{"location":"Resources-and-References/","title":"Resources And References","text":""},{"location":"Resources-and-References/#staying-informed","title":"Staying Informed","text":"<p>Continuing education is important to maintain one\u2019s skills, so much so that it\u2019s mentioned in the ACM Code of Ethics. Finding better ways to develop software, whether techniques/processes or tools/technologies, is beneficial to the organization. In addition, continual learning is beneficial to one\u2019s personal state of mind. Conferences (what is EOL/CDS policy on attendance?), courses, and user groups provide good social exposure. Online resources often provide the most currency. Reading code is a useful and important way to improve skills, as is reading books (and reading books about reading code).</p>"},{"location":"Resources-and-References/#sea","title":"SEA","text":"<ul> <li>UCAR Software Engineering Assembly</li> </ul>"},{"location":"Resources-and-References/#stack-overflow","title":"Stack Overflow","text":"<ul> <li>Stack Overflow (collaborative Q&amp;A)</li> </ul>"},{"location":"Resources-and-References/#tech-news","title":"Tech News","text":"<ul> <li>Freshnews (aggregator)</li> <li>Hacker News (community-moderated bookmarks; some news, some fun, some pointers to new tech or tutorials)</li> </ul>"},{"location":"Resources-and-References/#professional-organizations","title":"Professional Organizations","text":"<ul> <li>ACM</li> <li>USENIX</li> <li>IEEE Computer Society</li> </ul>"},{"location":"Resources-and-References/#project-template","title":"Project Template","text":"<ul> <li>Software Project Template</li> </ul>"},{"location":"Resources-and-References/#joel-test","title":"Joel Test","text":"<ul> <li>The Joel Test: 12 Steps to Better Code</li> <li>Joel on Software</li> </ul>"},{"location":"Resources-and-References/#agile-on-wikipedia","title":"Agile on Wikipedia","text":"<ul> <li>Agile software development article on Wikipedia.   See especially the Agile Manifesto section.</li> </ul>"},{"location":"Resources-and-References/#ptolemy-project","title":"Ptolemy Project","text":"<ul> <li>Software Practice in the Ptolemy Project</li> </ul>"},{"location":"Resources-and-References/#google-style-guide","title":"Google Style Guide","text":"<ul> <li>Google style guide</li> </ul>"},{"location":"Resources-and-References/#ral-wiki","title":"RAL Wiki","text":"<p>RAL Software Engineering Standards: SEA Presentation by Gerry Wiener and the RAL Software Engineering wiki page.</p>"},{"location":"Resources-and-References/#commit-messages","title":"Commit Messages","text":"<ul> <li>Peter Hutterer On commit messages</li> </ul>"},{"location":"Resources-and-References/#kde-policies","title":"KDE Policies","text":"<ul> <li>KDE Software Development Policies: See   especially the Commit Policy, Library Code Policy, and Kdelibs Coding Style.</li> </ul>"},{"location":"Resources-and-References/#eol-wiki","title":"EOL Wiki","text":"<p>The EOL Software Engineering Wiki is an internal resource which only allows authorized access. It has details on specific tools, libraries, and hardware in use in EOL.</p>"},{"location":"Resources-and-References/#scott-meyers","title":"Scott Meyers","text":"<ul> <li>Meyers, Scott. Effective C++: 50 Specific Ways to Improve Your Programs and Design.</li> <li>Meyers, Scott. Effective Modern C++</li> </ul>"},{"location":"Resources-and-References/#design-patterns","title":"Design Patterns","text":"<ul> <li>Gamma, Helm, Johnson, Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software.</li> </ul>"},{"location":"Resources-and-References/#uml-distilled","title":"UML Distilled","text":"<ul> <li>Fowler, Martin. UML Distilled.</li> </ul>"},{"location":"Resources-and-References/#head-first","title":"Head First","text":"<ul> <li>Pilone, Dan and Miles, Russ; Head First Software Development, on Safari Books Online. See Ch 1, pg 10, \u201cGetting to the goal with ITERATION\u201d</li> </ul>"},{"location":"Resources-and-References/#code-of-ethics","title":"Code of Ethics","text":"<ul> <li>ACM Code of Ethics</li> </ul>"},{"location":"Resources-and-References/#why-scientific-programming-does-not-compute","title":"Why scientific programming does not compute","text":"<ul> <li>Computational science: \u2026Error: why scientific programming does not compute. Published online 13 Oct 2010, Nature 467, 775-777 (2010)</li> </ul>"},{"location":"Resources-and-References/#more-books","title":"More Books","text":"<ul> <li>Warren, Henry S. Hacker\u2019s delight.</li> <li>Bentley, Jon Louis. Programming pearls.</li> <li>Spinellis, Diomidis. Code reading.</li> <li>Kernighan, Brian W. and Rob Pike. The practice of programming.</li> </ul>"},{"location":"Software-Project-Template/","title":"Software Project Template","text":"<p>This is a template for an overview and checklist of a software development project. The intention is to provide a quick summary and an index of important links.</p> <p>There is a table rendition of this checklist for the CAMS project: CAMS LabVIEW Software Development.</p>"},{"location":"Software-Project-Template/#software-project-overview-template-spot-fields","title":"Software Project Overview Template (SPOT) Fields","text":""},{"location":"Software-Project-Template/#name","title":"Name:","text":"<p>Example: Hello World</p>"},{"location":"Software-Project-Template/#description","title":"Description:","text":"<p>Example: As part of the observation sensing network, this software will monitor hardware sensors and display \u201cHello World\u201d whenever the instrument is being observed by someone, and otherwise it will do nothing.</p>"},{"location":"Software-Project-Template/#inception-date","title":"Inception date:","text":"<p>Just to give some idea of the age of the project.</p>"},{"location":"Software-Project-Template/#current-status","title":"Current status:","text":"<p>Use this to distinguish lifecycle phases, from inception to active development to maintenance. The status fields used in the software inventory might already suffice for this.</p>"},{"location":"Software-Project-Template/#release-information","title":"Release information:","text":"<p>Give the current version, if any, where downloads are available, perhaps upcoming release dates.</p>"},{"location":"Software-Project-Template/#software-process","title":"Software process:","text":"<p>Identify the parts of the software guideline chosen to be followed for this project, or name a specific process to be followed, like XP or TDD or pair programming. The point is not to restrict or formalize the process, only to think about it ahead of time and to give developers on the project a picture of how the process should work.</p>"},{"location":"Software-Project-Template/#revision-control-links","title":"Revision control links:","text":"<p>Provide URLs to subversion or git repositories for this software which developers and others should use to access the source.</p>"},{"location":"Software-Project-Template/#links-to-other-software-artifacts","title":"Links to other software artifacts:","text":"<p>For example, this could be links to web documentation or wiki pages for discussion.</p>"},{"location":"Software-Project-Template/#developers","title":"Developers:","text":"<p>List the programmers on this project, who are not necesarily all software engineers.</p>"},{"location":"Software-Project-Template/#users","title":"Users:","text":"<p>Name the intended users of this software. Again, the idea is to be clear and complete about for whom the software needs to work. This could be only a few specific people if it\u2019s a one-off data analysis, or it could be the entire research radar community. The users will be scientists or engineers or technicians or the general public, but almost absolutely the users will not be just other software engineers.</p>"},{"location":"Software-Project-Template/#domain-experts","title":"Domain experts:","text":"<p>Name specific people who will consult on technical matters related to the software\u2019s domain. This could be one or several people. The domain experts may also be users, but not necessarily. These are the people the developers must go to to resolve questions about the requirements, the problem being solved, or the vocabulary and concepts specific to the domain. If the software will process radar data, the domain experts likely will include a radar scientist or engineer. In many cases the developers might also be considered domain experts. The point is that software development requires intimate understanding of the problem domain, and it\u2019s important to recognize the role of domain expert and to rely on that resource for development.</p>"},{"location":"Software-Project-Template/#requirements-overview","title":"Requirements overview:","text":"<p>For simple projects, just state the requirements. For larger projects, provide a link to the requirements discussion or documentation. Obviously it is important to be able to state the requirements to keep the big picture in mind and as a check on the direction of development. For iterative agile development processes, these are not the requirements of each individual development stage. These are the guides by which the final product will be judged whether it works or not.</p>"},{"location":"Software-Project-Template/#design-overview","title":"Design overview:","text":"<p>Provide the basic approach to the design or a link to it. As for requirements, this just gives an idea of the fundamental design. The larger the project, the more complicated this can be. Note that it is useful to document critical design alternatives which were considered but rejected.</p>"},{"location":"Software-Project-Template/#security-issues","title":"Security issues:","text":"<p>Don\u2019t forget to think about security implications: data security (including redundancy and access restrictions), system reliability, operator authentication, logging and auditing, user privacy, and so on.</p>"},{"location":"Software-Project-Template/#related-projects","title":"Related projects:","text":"<p>Name projects or provide links to projects which are similar or somehow related to this project. It\u2019s important to think about this to identify what parts of the problem might have already been solved or to find out what has been learned from past mistakes.</p>"},{"location":"Software-Project-Template/#implementation-overview","title":"Implementation overview:","text":"<p>These are nuts and bolts questions to answer at the beginning of the project. They give an idea of the development and deployment environments, and they are a checklist for infrastructure which should be in place when the project begins.</p>"},{"location":"Software-Project-Template/#programming-languages","title":"Programming languages:","text":"<p>C++, Java, Ruby, Perl, Python, ad infinitum</p>"},{"location":"Software-Project-Template/#platforms","title":"Platforms:","text":"<p>Linux embedded, Linux desktop, web server, Windows, Mac, \u2026</p>"},{"location":"Software-Project-Template/#data-formats","title":"Data formats:","text":""},{"location":"Software-Project-Template/#gui-framework","title":"GUI framework:","text":""},{"location":"Software-Project-Template/#build-system","title":"Build system:","text":"<p>Examples: SCons, make, qmake, automake, cmake, Visual Studio, \u2026</p>"},{"location":"Software-Project-Template/#sources-for-test-data","title":"Sources for test data:","text":"<p>It is important to identify test data from the start, since sometimes it will take a while to obtain them, and sometimes the design of the instrument and the software must specifically be designed to accommodate test data. Virtually all EOL software projects will either consume or produce data, or both, and there must be some way to verify the operation initially, then later also verify that maintenance and improvements do not produce unexpected results. For research instruments collecting one-chance-only observational data in the field, it is especially critical that data not be lost or munged on their way through software. Having test data easily accessible, perhaps even packaged with the software, makes it easier for others to try out the software and run their own tests.</p>"},{"location":"Software-Project-Template/#test-frameworks","title":"Test frameworks:","text":"<p>There are many testing frameworks and utilities available. Even if a specific framework is not chosen, it should be possible to identify how tests will be automated, such as with scripts or built into the program.</p>"},{"location":"Software-Project-Template/#other-frameworks-and-libraries","title":"Other frameworks and libraries:","text":"<p>Examples: Boost, OpenDDS, Qwt, Netcdf, Jambi, and so on.</p>"},{"location":"Software-Project-Template/#links-to-automated-build-cit-reports","title":"Links to automated build (CIT) reports:","text":"<p>Examples: buildbot</p>"},{"location":"Software-Project-Template/#links-to-issue-tracker","title":"Links to issue tracker:","text":"<p>This is a reminder to setup a place to record problem reports and feature requests. Once that\u2019s created, this is a convenient place to put a link to it. Examples: JIRA Bugzilla Github</p>"},{"location":"Tools-and-Technologies/","title":"Tools and Technologies","text":""},{"location":"Tools-and-Technologies/#editing","title":"Editing","text":"<p>There are several tools in use in EOL for editing source code. Besides emacs and vi, there are Integrated Development Environments (IDE) VS Code, Eclipse, and JetBrains. No particular IDE or tool should be mandated or standardized across EOL, since that runs contrary to flexibility, individuality, and the investigation of new technology. Instead, we can continue to encourage communication, share what works, and consolidate tools when prudent.</p>"},{"location":"Tools-and-Technologies/#revision-control","title":"Revision Control","text":"<p>There are two major revision control tools in use in EOL: subversion and git. It makes sense to standardize on these two since the infrastructure is in place and there has been plenty of experience with them. There is an EOL organization at github for both private and public repositories. By now most new projects should use the NCAR organization on github.  There is also a subversion server in EOL, but most software has migrated away from that to github.  See the EOL wiki for more information on git, subversion, and migrating to git.</p>"},{"location":"Tools-and-Technologies/#unit-testing","title":"Unit Testing","text":"<p>Test-driven development is a valuable practice that can be used in projects of any scale. It forces developers to consider requirements and expected behaviour from the beginning, and then unit tests verify the behavior and provide some assurances that code still works after the changes. Various libraries and harnesses have been used in EOL to facilitate testing.</p> <p>Java in general can use JUnit, for which Eclipse has plugins.</p> <p>For python, there are pylint and unittest and py.test.</p> <p>C++ projects have used CppUnit, Boost Test, CxxTest, and Google Test.</p>"},{"location":"Tools-and-Technologies/#memory-checking","title":"Memory Checking","text":"<p>A valuable tool for checking for memory errors in an application is valgrind. It is a very good practice to run compiled applications through valgrind. If the tests can be scripted and automated, then valgrind can easily check for memory errors and memory leaks each time the tests are run. The more source code exercised by the tests (code coverage), the more thorough the memory checking.</p>"},{"location":"Tools-and-Technologies/#issue-tracking","title":"Issue Tracking","text":"<p>The default issue tracking tool in EOL was JIRA, and several projects still use it. However, github has its own issue tracking, and sometimes a wiki is used to track issues. Email does not make a good issue tracking tool, because the thread is spread across emails, it is difficult to catch someone up, and it is difficult to search for past similar issues. Note that field deployment issues can be tracked and not just software issues. UCAR JIRA is now used to track the tasks and problems related to software and systems deployments for various ISF and RAF platforms.</p>"},{"location":"Tools-and-Technologies/#continuous-integration","title":"Continuous Integration","text":"<p>EOL migrated from Buildbot to Jenkins for continuous integration and testing. See the EOL Software Engineering Wiki for information on how to use the EOL instance.</p>"},{"location":"Tools-and-Technologies/#builds","title":"Builds","text":"<p>EOL software has been known to use make, autoconf, shell scripts, SCons, Visual Studio, cmake, and qmake to build and install. There are many possibilities, but should EOL try to settle on just a few? SCons is used by several projects in EOL, and many of them share extensions to SCons called eol_scons.</p>"},{"location":"Tools-and-Technologies/#code-reviews","title":"Code Reviews","text":"<p>There seems to be two common approaches to code reviews: emails and github comments.  It has been very helpful and effective to send email notifications on each code commit, especially if they contain diffs.  Then other developers know what is being changed and can reply with comments about the changes. Github also provides ways to comment on pull requests and directly on code in commits, and that has proved convenient and effective also.  Formal code reviews, however, have probably only rarely happened in EOL, if ever.</p>"},{"location":"Tools-and-Technologies/#packaging-distribution-and-installation","title":"Packaging, Distribution, and Installation","text":"<p>Some projects provide targets to assemble an installation package. The package can be an RPM or a tar.gz file. Providing a standard installation package facilitates deployment to multiple field systems and to internal EOL servers. RPM\u2019s can be deployed through the EOL YUM repository.</p> <p>If an application is being installed from the source tree, such as with a build target, or it is being packaged in an archive, then certain conventions should be followed as to where to install the necessary files. Linux has a standard for where files are installed on a system called the Linux Standards Base. Likewise, it is good practice to not install unstable software into production locations. On EOL servers and desktop systems, these directories are for stable, production software: /usr and other system directories, /usr/local, and shared network directories like /net/opt_lnx, /opt/local. Do not install by default into these locations, lest operational versions get overwritten. For Linux installations, follow the standard layout of lib, bin, and include subdirectories beneath a configurable prefix directory.</p> <p>It is helpful to have a single build target for installing from within a source tree. This allows multiple software packages to be installed into a single integration test tree and run against each other, without affecting the rest of the system. When source code changes in one source tree, the build installs the changed files so that other packages will build against the latest changes from the integration tree.</p> <p>It is not known what is the best practice for installing libraries and source needed to build software. Sometimes a common prefix can be used for all dependencies, other times packages will have their own separate installation tree, and those directories will need to be added explicitly to the build paths.</p> <p>There is a recommended installer tool for Windows applications, used in particular by ASPEN. Ask Charlie about it.</p>"},{"location":"Tools-and-Technologies/#graphical-user-interface-frameworks","title":"Graphical User Interface Frameworks","text":"<p>The majority of current EOL (non-Web-based) applications use Qt. Should that become the preferred GUI library for EOL? Other GUI frameworks have been used over the years, but experience and current practice suggest that using Qt for GUI applications is a best practice in EOL. That could include Qt bindings in python using either PyQt or PySide.</p>"},{"location":"Tools-and-Technologies/#web-application-frameworks","title":"Web Application Frameworks","text":"<p>There are many web applications developed in EOL using several technologies, including Ruby on Rails, Groovy with Grail, Django, HTML, Javascript, Tomcat, Python CGI, ION (IDL), PHP, Mapserver, Perl CGI, Java Server Pages, and so on. It would be difficult to standardize on a particular web technology since they change so quickly and since there is no clear trend in EOL. Nevertheless, maybe a few standard web frameworks should be considered. At the very least, before adopting yet another web application platform, consider very carefully the long-term maintenance of the application. Now there is also a variety of JavaScript libraries to choose from.</p>"},{"location":"Tools-and-Technologies/#application-configuration","title":"Application Configuration","text":"<p>There are many mechanisms and libraries to configure applications at runtime. There are Windows INI files, for which there are few different libraries in use. Qt provides a cross-platform configuration API that stores configuration parameters as INI files. Boost provides an API for command-line and file- backed program options, as well as a serialization library. There are the standard getopt() and getenv() GNU and POSIX calls. Java now has a standard API for application configuration (Java Preferences API), besides also having core support for serialization (persistence). Some applications store configuration data in XML and use the Apache Xerces-C library to read and write XML files. Here are some guidelines despite all this variety:</p> <ul> <li> <p>Use a text-based, line-based configuration file format, even if users will   never be expected to edit the configuration files. This format can be   deciphered by developers when there are problems, and different versions of   configuration files can be managed and compared by revision control systems.   It is a good practice to store examples of configuration files as well as   test and production configurations in revision control.</p> </li> <li> <p>Related to revision control, when modifying a configuration in software,   avoid gratuitous formatting or structure changes (like changing node order)   so that differences between revisions will be meaningful. In the XML DOM   this is possible by modifying the document model in parallel with the   configuration changes. Other formats might require always ordering nodes   alphabetically when writing them out.</p> </li> <li> <p>Provide as many reasonable defaults as possible, so software can work as   quickly and as automatically as possible without requiring too much   configuration from the user.</p> </li> </ul>"},{"location":"Tools-and-Technologies/#commercial-tools","title":"Commercial Tools","text":"<p>It seems we should identify some best practices for selecting and adopting commercial tools. There may be IDE\u2019s, memory checkers, static analysis and code coverage tools, advanced compilers, web and GUI test harnesses, database tools, and software diagramming tools which would be worth their cost to EOL, but we do not have any methods in place to evaluate them. The best approach may be to suggest that developers seek out tools that may be helpful for a particular project and then report on whether the tools should be used more widely in EOL. EOL has taken advantage of commercial tools for which there are UCAR site licenses, such as the MagicDraw UML tool and the Atlassian products.</p> <p>Tools like LabVIEW and FPGA compilers are also used in EOL for specialized needs.</p>"},{"location":"Tools-and-Technologies/#code-analysis-tools","title":"Code Analysis Tools","text":"<p>Memory checking tools have been used in the past, such as Purify and Testcenter, and they proved useful. Perhaps it is time to adopt the latest generation of such tools. CERN has benefitted from the static code analysis tool Coverity, the tool known for checking the Linux kernel. Here is a list of \u201cmore well- known\u201d commercial code analysis tools:</p> <ul> <li>Coverity</li> <li>Parasoft</li> <li>LDRA Testbed</li> </ul> <p>Likely EOL software would benefit from at least adopting open source and research code analysis tools into the development process. A quick search of the web yields a few possibilities, at least for Linux and C++. There are also many for Java and Python (pylint).</p> <ul> <li>Splint</li> <li>Mozilla Static Analysis Tools</li> <li>CppCheck</li> </ul> <p>Next page: Logging Frameworks</p>"},{"location":"Updating-the-Guidelines/","title":"Updating the Guidelines","text":"<p>It is important to review and update these guidelines based on latest industry \u201cbest practices\u201d or \u201cgood operating practices\u201d, as those practices evolve and as EOL learns how to apply them best to EOL projects.</p>"},{"location":"Updating-the-Guidelines/#process-review","title":"Process review","text":"<p>Should there be a process for updating these guidelines? A periodic review? Should there be a \u201cfacilitation team\u201d to help those doing software development (not necessarily just programmers) put the guidelines and suggested practices to good use? Such a team would be the natural place to house infrastructure support for things like subversion, git, jira, websvn, MoinMoin and fisheye.</p> <p>How should we determine when and how the guidelines should be applied to different projects? Should this report document specific adjustments for different groups? For example, CTM and DMG software projects may have different practices, and some SSG practices may not apply outside of instrument developments. Perhaps the point needs to be made that these guidelines should be kept as universal as possible, so they can be applied consistently throughout EOL.</p>"},{"location":"Updating-the-Guidelines/#practice-priming","title":"Practice priming","text":"<p>New hires should be enculturated into a project on their first day. A mentor should guide them through writing production code following the specific project practices chosen from these guidelines (as described in the project checklist/overview). Old hands on new projects should do similar - either be mentored through their first day on a project, or pair-program and mutually discover/reinforce proper practices. These processes can feed into a project- practice iteration.</p>"},{"location":"Updating-the-Guidelines/#action-items","title":"Action items","text":"<p>If there are some specific action items which should follow from these guidelines, then list them here.</p> <p>Encourage more use of issue tracking, and if necessary consolidate on JIRA as the issue tracking tool. This does not need to include users at this point, but if we\u2019re not keeping track of bug reports and issues from our users, then we\u2019re not doing the best we can to be accountable to them.</p> <p>Blog? Perhaps a shared blog, or a planet gateway to individual blogs, would be a convenient way to hear about what other developers are doing and how developments are going. It might also be a convenient way to log progress and to report on milestones, and the blogs would be available to anyone interested, including managers and other project team members (not just programmers). The blog could be part of a confluence wiki for EOL software development, perhaps migrated from the Software Engineering Wiki.</p>"},{"location":"Updating-the-Guidelines/#open-questions","title":"Open Questions","text":"<p>Issues which were considered outside the scope of this report and deliberately were not addressed.</p> <p>Should there be guidelines about how to decide whether to purchase and adopt commercial software solutions? This could include IDEs, software analyzers and debuggers, and high-performance compilers. Likewise, should there be guidelines about when to use outside code?</p> <p>How to publish and advertise these guidelines, and to whom (besides software engineers)?</p> <p>The single point of failure problem is mentioned briefly in the shared programming practice, but what other practices have been used or could be used? Provide training sessions for other developers? Have another developer write the documentation? Get more programmers involved in bug fix phases to learn by doing? Send multiple developers to support a field project (trial by fire)?</p> <p>Can anyone name a formal process they have used in the past? What worked well, what didn\u2019t? Is there one particular process we should suggest as a model to follow, eg XP, TDD, Scrum?</p> <p>As an interesting side question, Google development is restricted to three languages: C++, Java, and Python. Unidata several years ago decided to concentrate on Java. Should EOL consolidate on a few languages?</p> <p>Next page: Resources and References</p>"}]}